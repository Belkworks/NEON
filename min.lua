local a;a=function(b,c)for d in pairs(c)do if b[d]==nil then b[d]=c[d]end end end;local e;e=function(c)return c:gsub('.',function(f)return string.format('%02X',string.byte(f))end)end;local g;do local h;local i={__call=function(self,j)return self:raw(j)end,_debug=function(self,...)if not self.DEBUG then return end;return print('[DEBUG]',...)end,_error=function(self,k)error(k)end,_http=function(self,j,l)if l==nil then l={}end;if not syn then return self:_error('your exploit does not support http requests!')end;if not('string'==type(j))then return self:_error('invalid url passed to :_http')end;self:_debug("web request for "..tostring(l.tag).." to "..tostring(j))return syn.request({Url=j,Method='GET',Headers=l.headers or{},Cookies=l.cookies or{},Body=l.body or nil})end,_cache=function(self,m,n)self.cache[m]=n end,_cachecheck=function(self,o,l)if l==nil then l={}end;if l.fresh then return end;do local p=self.cache[o]if p then self:_debug("serving "..tostring(o).." from cache")return p end end end,_loadstring=function(self,q,l)if l==nil then l={}end;local r,s=pcall(loadstring,q)if r then return s else return self:_error("error loadstring "..tostring(l.tag)..": "..tostring(s))end end,_executeChunk=function(self,t,l)if l==nil then l={}end;local u={pcall(t)}local v=table.remove(u,1)if v then self:_cache(l.tag,u)return unpack(u)else local w=table.remove(u,1)return self:_error('error execute #{options.tag}: #{err}')end end,_execute=function(self,q,l)if l==nil then l={}end;if not('table'==type(l))then return self:_error('invalid options passed to :_execute')end;if not('string'==type(l.tag))then return self:_error('invalid tag passed to :_execute')end;self:_debug("loading "..tostring(l.tag))local t=self:_loadstring(q,l)if l.cache then self:_writefile(q,l)end;return self:_executeChunk(t,l)end,clearCache=function(self,x)do x=tostring(x)if x then self.cache[x]=nil else self.cache={}end end end,web=function(self,j,l)if l==nil then l={}end;if not('table'==type(l))then return self:_error('invalid options passed to :raw')end;a(l,{tag="web:"..tostring(j),cache=true})if not('string'==type(l.tag))then return self:_error('invalid tag passed to :raw')end;do local y=self:_cachecheck(l.tag,l)if y then return unpack(y)end end;local z,u=self:_fromTag(l.tag)if z then return u end;local A=self:_http(j,l)if A.Success then return self:_execute(A.Body,l)else return self:_error("failed http request to "..tostring(j))end end,pastebin=function(self,B,l)if l==nil then l={}end;if not('string'==type(B))then return self:_error('invalid id passed to :pastebin')end;a(l,{tag="pastebin:"..tostring(B)})return self:web("https://pastebin.com/raw/"..tostring(B),l)end,github=function(self,C,D,E,F,l)if E==nil then E='init.lua'end;if F==nil then F='master'end;if l==nil then l={}end;if not('string'==type(C))then return self:_error('no user passed to :github')end;if not('string'==type(D))then return self:_error('no repo passed to :github')end;if not('string'==type(E))then return self:_error('no file passed to :github')end;if not('string'==type(F))then return self:_error('no branch passed to :github')end;a(l,{tag="github:"..tostring(C).."/"..tostring(D).."["..tostring(F).."]/"..tostring(E)})do local G='https://raw.githubusercontent.com/%s/%s/%s/%s'local j=G:format(C,D,F,E)return self:web(j,l)end end,_makeDirectories=function(self)if not isfolder('neon')then makefolder('neon')end;if not isfolder('neon/cache')then return makefolder('neon/cache')end end,_fromTag=function(self,o,l)if l==nil then l={}end;if l.fresh then return end;self:_makeDirectories()a(l,{maxAge=7*24*60*60})if self.packages and not l.force then do local H=self.packages:get(o)if H then if os.time()-H.time>l.maxAge then return end else return end end end;local I=e(syn.crypt.derive(o,12))local J="neon/cache/"..tostring(I)..".bin"if isfile(J)then do local K=readfile(J)if K then self:_debug("read "..tostring(o).." from file")return true,self:_execute(K,{tag=o,cache=false})end end end end,_writefile=function(self,q,l)self:_makeDirectories()local I=e(syn.crypt.derive(l.tag,12))local J="neon/cache/"..tostring(I)..".bin"local L=dumpstring(q)writefile(J,L)if self.packages then self.packages:set(l.tag,{time=os.time()})self.manifest:write()end;return self:_debug("wrote "..tostring(l.tag).." to file as "..tostring(I))end,init=function(self)if not syn then self:_error('platform not supported!')end;self:_makeDirectories()local o='github:safazi/flat/init.lua'local M=self:github('safazi','flat')do local G=M('neon/manifest.json')self.packages=G:namespace('packages')self.manifest=G end;if not self.packages:get(o)then self.packages:set(o,{time=os.time()})end;return self.manifest:write()end,__call=function(self,...)return self:github(...)end}i.__index=i;h=setmetatable({__init=function(self,l)if l==nil then l={}end;a(l,{debug=false})self.DEBUG=l.debug;self.cache={}return self:init()end,__base=i,__name="Neon"},{__index=i,__call=function(N,...)local O=setmetatable({},i)N.__init(O,...)return O end})i.__class=h;g=h end;local P=g;if getgenv then getgenv().NEON=P end;return P